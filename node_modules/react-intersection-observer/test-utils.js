"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_utils_1 = require("react-dom/test-utils");
const observerMap = new Map();
const instanceMap = new Map();
beforeAll(() => {
    // @ts-ignore
    global.IntersectionObserver = jest.fn((cb, options) => {
        const instance = {
            thresholds: Array.isArray(options.threshold)
                ? options.threshold
                : [options.threshold],
            root: options.root,
            rootMargin: options.rootMargin,
            time: Date.now(),
            observe: jest.fn((element) => {
                instanceMap.set(element, instance);
                observerMap.set(element, cb);
            }),
            unobserve: jest.fn((element) => {
                instanceMap.delete(element);
                observerMap.delete(element);
            }),
            disconnect: jest.fn(),
        };
        return instance;
    });
});
afterEach(() => {
    // @ts-ignore
    global.IntersectionObserver.mockClear();
    instanceMap.clear();
    observerMap.clear();
});
/**
 * Set the `isIntersecting` on all current IntersectionObserver instances
 * @param isIntersecting {boolean}
 */
function mockAllIsIntersecting(isIntersecting) {
    observerMap.forEach((onChange, element) => {
        mockIsIntersecting(element, isIntersecting);
    });
}
exports.mockAllIsIntersecting = mockAllIsIntersecting;
/**
 * Set the `isIntersecting` for the IntersectionObserver of a specific element.
 * @param element {Element}
 * @param isIntersecting {boolean}
 */
function mockIsIntersecting(element, isIntersecting) {
    const cb = observerMap.get(element);
    const instance = instanceMap.get(element);
    if (cb && instance) {
        const entry = [
            {
                boundingClientRect: element.getBoundingClientRect(),
                intersectionRatio: isIntersecting ? 1 : 0,
                intersectionRect: isIntersecting ? element.getBoundingClientRect() : {},
                isIntersecting,
                rootBounds: instance.root ? instance.root.getBoundingClientRect() : {},
                target: element,
                time: Date.now() - instance.time,
            },
        ];
        if (test_utils_1.act)
            test_utils_1.act(() => cb(entry, instance));
        else
            cb(entry, instance);
    }
    else {
        throw new Error('No IntersectionObserver instance found for element. Is it still mounted in the DOM?');
    }
}
exports.mockIsIntersecting = mockIsIntersecting;
/**
 * Call the `intersectionMockInstance` method with an element, to get the (mocked)
 * `IntersectionObserver` instance. You can use this to spy on the `observe` and
 * `unobserve` methods.
 * @param element {Element}
 * @return IntersectionObserver
 */
function intersectionMockInstance(element) {
    return instanceMap.get(element);
}
exports.intersectionMockInstance = intersectionMockInstance;
