"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _getStaticDir = require("../utils/get-static-dir");

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _chalk = _interopRequireDefault(require("chalk"));

var _gatsbyTelemetry = _interopRequireDefault(require("gatsby-telemetry"));

var _express = _interopRequireDefault(require("express"));

var _schemaHotReloader = require("../bootstrap/schema-hot-reloader");

var _pageHotReloader = _interopRequireDefault(require("../bootstrap/page-hot-reloader"));

var _tracer = require("../utils/tracer");

var _db = _interopRequireDefault(require("../db"));

var _detectPortInUseAndPrompt = require("../utils/detect-port-in-use-and-prompt");

var _signalExit = _interopRequireDefault(require("signal-exit"));

var _query = _interopRequireDefault(require("../query"));

var _queryWatcher = _interopRequireDefault(require("../query/query-watcher"));

var requiresWriter = _interopRequireWildcard(require("../bootstrap/requires-writer"));

var _waitUntilJobsComplete = require("../utils/wait-until-jobs-complete");

var _feedback = require("../utils/feedback");

var _redirectsWriter = require("../bootstrap/redirects-writer");

var _webpackStatus = require("../utils/webpack-status");

var _services = require("../services");

var _actions = require("../redux/actions");

var _types = require("../redux/types");

var _xstate = require("xstate");

var _dataLayer = require("../state-machines/data-layer");

var _opentracing = require("opentracing");

var _queryRunning = require("../state-machines/query-running");

const tracer = (0, _opentracing.globalTracer)(); // const isInteractive = process.stdout.isTTY
// Watch the static directory and copy files to public as they're added or
// changed. Wait 10 seconds so copying doesn't interfere with the regular
// bootstrap.

setTimeout(() => {
  (0, _getStaticDir.syncStaticDir)();
}, 10000); // Time for another story...
// When the parent process is killed by SIGKILL, Node doesm't kill spawned child processes
// Hence, we peiodically send a heart beat to the parent to check if it is still alive
// This will crash with Error [ERR_IPC_CHANNEL_CLOSED]: Channel closed
// and kill the orphaned child process as a result

if (process.send) {
  setInterval(() => {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    process.send({
      type: `HEARTBEAT`
    });
  }, 1000);
}

(0, _signalExit.default)(() => {
  _gatsbyTelemetry.default.trackCli(`DEVELOP_STOP`);
});
process.on(`message`, msg => {
  if (msg.type === `COMMAND` && msg.action.type === `EXIT`) {
    process.exit(msg.action.payload);
  }
});

module.exports = async program => {
  const bootstrapSpan = tracer.startSpan(`bootstrap`); // We want to prompt the feedback request when users quit develop
  // assuming they pass the heuristic check to know they are a user
  // we want to request feedback from, and we're not annoying them.

  process.on(`SIGINT`, async () => {
    if (await (0, _feedback.userPassesFeedbackRequestHeuristic)()) {
      (0, _feedback.showFeedbackRequest)();
    }

    process.exit(0);
  });

  if (process.env.GATSBY_EXPERIMENTAL_PAGE_BUILD_ON_DATA_CHANGES) {
    _reporter.default.panic(`The flag ${_chalk.default.yellow(`GATSBY_EXPERIMENTAL_PAGE_BUILD_ON_DATA_CHANGES`)} is not available with ${_chalk.default.cyan(`gatsby develop`)}, please retry using ${_chalk.default.cyan(`gatsby build`)}`);
  }

  (0, _tracer.initTracer)(program.openTracingConfigFile);
  (0, _webpackStatus.markWebpackStatusAsPending)();

  _reporter.default.pendingActivity({
    id: `webpack-develop`
  });

  _gatsbyTelemetry.default.trackCli(`DEVELOP_START`);

  _gatsbyTelemetry.default.startBackgroundUpdate();

  const port = typeof program.port === `string` ? parseInt(program.port, 10) : program.port;

  try {
    program.port = await (0, _detectPortInUseAndPrompt.detectPortInUseAndPrompt)(port);
  } catch (e) {
    if (e.message === `USER_REJECTED`) {
      process.exit(0);
    }

    throw e;
  }

  const app = (0, _express.default)();
  const developConfig = {
    id: `build`,
    initial: `initializing`,
    states: {
      initializing: {
        invoke: {
          src: `initialize`,
          onDone: {
            target: `initializingDataLayer`,
            actions: `assignStoreAndWorkerPool`
          }
        }
      },
      initializingDataLayer: {
        invoke: {
          src: `initializeDataLayer`,
          data: ({
            parentSpan,
            store
          }) => {
            return {
              parentSpan,
              store,
              firstRun: true
            };
          },
          onDone: {
            actions: `assignDataLayer`,
            target: `finishingBootstrap`
          }
        }
      },
      finishingBootstrap: {
        invoke: {
          src: async ({
            gatsbyNodeGraphQLFunction
          }) => {
            // These were previously in `bootstrap()` but are now
            // in part of the state machine that hasn't been added yet
            await (0, _services.rebuildSchemaWithSitePage)({
              parentSpan: bootstrapSpan
            });
            await (0, _services.writeOutRedirects)({
              parentSpan: bootstrapSpan
            });
            (0, _redirectsWriter.startRedirectListener)();
            bootstrapSpan.finish();
            await (0, _services.postBootstrap)({
              parentSpan: bootstrapSpan
            }); // These are the parts that weren't in bootstrap
            // Start the createPages hot reloader.

            (0, _pageHotReloader.default)(gatsbyNodeGraphQLFunction); // Start the schema hot reloader.

            (0, _schemaHotReloader.bootstrapSchemaHotReloader)();
          },
          onDone: {
            target: `runningQueries`
          }
        }
      },
      runningQueries: {
        invoke: {
          src: `runQueries`,
          data: ({
            program,
            store,
            parentSpan,
            gatsbyNodeGraphQLFunction,
            graphqlRunner,
            firstRun
          }) => {
            return {
              firstRun,
              program,
              store,
              parentSpan,
              gatsbyNodeGraphQLFunction,
              graphqlRunner
            };
          },
          onDone: {
            target: `doingEverythingElse`
          }
        }
      },
      doingEverythingElse: {
        invoke: {
          src: async ({
            workerPool,
            store,
            app
          }) => {
            // All the stuff that's not in the state machine yet
            await (0, _services.writeOutRequires)({
              store
            });

            _actions.boundActionCreators.setProgramStatus(_types.ProgramStatus.BOOTSTRAP_QUERY_RUNNING_FINISHED);

            await _db.default.saveState();
            await (0, _waitUntilJobsComplete.waitUntilAllJobsComplete)();
            requiresWriter.startListener();

            _db.default.startAutosave();

            _query.default.startListeningToDevelopQueue({
              graphqlTracing: program.graphqlTracing
            });

            _queryWatcher.default.startWatchDeletePage();

            await (0, _services.startWebpackServer)({
              program,
              app,
              workerPool
            });
          },
          onDone: {
            actions: (0, _xstate.assign)({
              firstRun: false
            })
          }
        }
      }
    }
  };
  const service = (0, _xstate.interpret)((0, _xstate.Machine)(developConfig, {
    services: {
      initializeDataLayer: _dataLayer.dataLayerMachine,
      initialize: _services.initialize,
      runQueries: _queryRunning.queryRunningMachine
    },
    actions: {
      assignStoreAndWorkerPool: (0, _xstate.assign)((_context, event) => {
        const {
          store,
          workerPool
        } = event.data;
        return {
          store,
          workerPool
        };
      }),
      assignDataLayer: (0, _xstate.assign)((_, {
        data
      }) => data)
    }
  }).withContext({
    program,
    parentSpan: bootstrapSpan,
    app,
    firstRun: true
  }));

  const isInterpreter = actor => `machine` in actor;

  const listeners = new WeakSet();
  let last;
  service.onTransition(state => {
    var _service$children;

    if (!last) {
      last = state;
    } else if (!state.changed || last.matches(state)) {
      return;
    }

    last = state;

    _reporter.default.verbose(`Transition to ${JSON.stringify(state.value)}`); // eslint-disable-next-line no-unused-expressions


    (_service$children = service.children) === null || _service$children === void 0 ? void 0 : _service$children.forEach(child => {
      // We want to ensure we don't attach a listener to the same
      // actor. We don't need to worry about detaching the listener
      // because xstate handles that for us when the actor is stopped.
      if (isInterpreter(child) && !listeners.has(child)) {
        let sublast = child.state;
        child.onTransition(substate => {
          if (!sublast) {
            sublast = substate;
          } else if (!substate.changed || sublast.matches(substate)) {
            return;
          }

          sublast = substate;

          _reporter.default.verbose(`Transition to ${JSON.stringify(state.value)} > ${JSON.stringify(substate.value)}`);
        });
        listeners.add(child);
      }
    });
  });
  service.start();
};
//# sourceMappingURL=develop-process.js.map