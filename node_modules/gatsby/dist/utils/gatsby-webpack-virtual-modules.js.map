{"version":3,"sources":["../../src/utils/gatsby-webpack-virtual-modules.ts"],"names":["fileContentLookup","instances","GatsbyWebpackVirtualModules","apply","compiler","virtualModules","VirtualModulesPlugin","push","writeModule","bind","filePath","fileContents","adjustedFilePath","forEach","instance"],"mappings":";;;;;;;;AAAA;;AAqBA,MAAMA,iBAAyC,GAAG,EAAlD;AACA,MAAMC,SAAgD,GAAG,EAAzD;;AAEO,MAAMC,2BAAN,CAAkC;AACvCC,EAAAA,KAAK,CAACC,QAAD,EAAiB;AACpB,UAAMC,cAAc,GAAG,IAAIC,8BAAJ,CAAyBN,iBAAzB,CAAvB;AACAK,IAAAA,cAAc,CAACF,KAAf,CAAqBC,QAArB;AACAH,IAAAA,SAAS,CAACM,IAAV,CAAe;AACbC,MAAAA,WAAW,EAAEH,cAAc,CAACG,WAAf,CAA2BC,IAA3B,CAAgCJ,cAAhC;AADA,KAAf;AAGD;;AAPsC;;;;AAUlC,SAASG,WAAT,CAAqBE,QAArB,EAAuCC,YAAvC,EAAmE;AACxE;AACA;AACA,QAAMC,gBAAgB,GAAI,gBAAeF,QAAS,EAAlD;;AAEA,MAAIV,iBAAiB,CAACY,gBAAD,CAAjB,KAAwCD,YAA5C,EAA0D;AACxD;AACA;AACD;;AAEDX,EAAAA,iBAAiB,CAACY,gBAAD,CAAjB,GAAsCD,YAAtC;AAEAV,EAAAA,SAAS,CAACY,OAAV,CAAkBC,QAAQ,IAAI;AAC5BA,IAAAA,QAAQ,CAACN,WAAT,CAAqBI,gBAArB,EAAuCD,YAAvC;AACD,GAFD;AAGD","sourcesContent":["import VirtualModulesPlugin from \"webpack-virtual-modules\"\n\n/*\n * This module allows creating virtual (in memory only) modules / files\n * that webpack compilation can access without the need to write module\n * body to actual filesystem.\n *\n * It's useful for intermediate artifacts that are not part of final builds,\n * but are used in some way to generate final ones (for example `async-requires.js`).\n *\n * Using virtual modules allow us to avoid unnecessary I/O to write/read those modules,\n * but more importantly using virtual modules give us immediate invalidation events\n * in webpack watching mode (as opposed to debounced/delayed events when filesystem is used).\n * Instant invalidation events make it much easier to work with various state transitions\n * in response to external events that are happening while `gatsby develop` is running.\n */\n\ninterface IGatsbyWebpackVirtualModulesContext {\n  writeModule: VirtualModulesPlugin[\"writeModule\"]\n}\n\nconst fileContentLookup: Record<string, string> = {}\nconst instances: IGatsbyWebpackVirtualModulesContext[] = []\n\nexport class GatsbyWebpackVirtualModules {\n  apply(compiler): void {\n    const virtualModules = new VirtualModulesPlugin(fileContentLookup)\n    virtualModules.apply(compiler)\n    instances.push({\n      writeModule: virtualModules.writeModule.bind(virtualModules),\n    })\n  }\n}\n\nexport function writeModule(filePath: string, fileContents: string): void {\n  // \"node_modules\" added in front of filePath allow to allow importing\n  // those modules using same path\n  const adjustedFilePath = `node_modules/${filePath}`\n\n  if (fileContentLookup[adjustedFilePath] === fileContents) {\n    // we already have this, no need to cause invalidation\n    return\n  }\n\n  fileContentLookup[adjustedFilePath] = fileContents\n\n  instances.forEach(instance => {\n    instance.writeModule(adjustedFilePath, fileContents)\n  })\n}\n"],"file":"gatsby-webpack-virtual-modules.js"}