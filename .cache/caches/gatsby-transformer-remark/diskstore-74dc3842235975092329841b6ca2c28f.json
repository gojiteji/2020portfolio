{"expireTime":9007200855781998000,"key":"transformer-remark-markdown-html-6f12b12559948d42fff75084569ec021-gatsby-remark-imagesgatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>Today we are going to write a compiler together this compiler is going to be the smallest compiler in the world. Since it's going to be a long article you can skip directly to the <a href=\"https://github.com/rolwin100/mini_compiler_demo\" target=\"_blank\" rel=\"nofollow\">code</a> if you can't wait 😅.</p>\n<p>Compilers are there everywhere, right from the point you switch ON your machine till you surf the web or open any application. So why do many developers tend to give less importance to it and don't have much knowledge on how it works 🤔. Probably they think compilers are too scary 👻 and only the nerdiest of the geeks 🤓 can work on it. But that not true. Compilers are quite simple. It's just that they involve a little understanding.</p>\n<p>Before jumping into what is a compiler and how compilers work. I'll explain what we are going to do in this article. We are going to write a code to compile a <a href=\"https://en.wikipedia.org/wiki/Lisp_(programming_language)\" target=\"_blank\" rel=\"nofollow\"><code class=\"language-text\">LISP</code></a> like function calls into C-like function calls. For those of you who don't know what is LISP, it's just a very old programming language like Fortran.</p>\n<p>For example if we have two functions <code class=\"language-text\">add</code> and <code class=\"language-text\">subtract</code> they would be written like this in LISP and C.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>LISP</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>2 + 2</strong></td>\n<td><code class=\"language-text\">(add 2 2)</code></td>\n<td><code class=\"language-text\">add(2, 2)</code></td>\n</tr>\n<tr>\n<td><strong>4 - 2</strong></td>\n<td><code class=\"language-text\">(subtract 4 2)</code></td>\n<td><code class=\"language-text\">subtract(4, 2)</code></td>\n</tr>\n<tr>\n<td><strong>2 + (4 - 2)</strong></td>\n<td><code class=\"language-text\">(add 2 (subtract 4 2))</code></td>\n<td><code class=\"language-text\">add(2, subtract(4, 2))</code></td>\n</tr>\n</tbody>\n</table>\n<h2></h2>\n<p>Easy-pezzy right? </p>\n<p>OK good!! we will be using the above example as the input for our compiler.</p>\n<h2>So what the hell is a compiler ? you may be asking ! 😂</h2>\n<p>So the compiler is a tool that just converts code from one programming language into another programming language without changing the actual meaning of the code. There is also something called a transpiler you may have come across while building JS application with typescript. A transpiler is also a compiler. So the difference between a compiler and a transpiler is that compiler converts code from a programming language to byte codes which humans can't understand. Whereas a transpiler is a source-to-source compiler i.e it converts code from one language to another and the compiled code is still human-readable.</p>\n<h2>stages in a compiler</h2>\n<p>Most of the compilers have three stages on a high level design i.e <code class=\"language-text\">Parsing</code>, <code class=\"language-text\">Transformation</code> and <code class=\"language-text\">Code Generation</code>.</p>\n<ol>\n<li><code class=\"language-text\">Parsing</code> is basically taking the code we are about to compile and turning it into an abstract representation.</li>\n<li><code class=\"language-text\">Transformation</code> is taking the output from the parsing stage and do whatever changes the compiler wants to do for the abstract representation.</li>\n<li><code class=\"language-text\">Code Generation</code> takes the output of transformation stage and converts it to the new Code.</li>\n</ol>\n<p>Thats it these are the three main stages of a compiler. 😃</p>\n<ol>\n<li>\n<h3>Parsing</h3>\n<p>Again parsing can be broken down into two phases <code class=\"language-text\">Lexical Analysis</code> and <code class=\"language-text\">Syntactic Analysis</code>.</p>\n<p><code class=\"language-text\">Lexical Analysis</code> takes the raw code and splits into token with the help of tokenizer also called as the lexer.</p>\n<p>For the following code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(add 2 (subtract 4 2))</code></pre></div>\n<p>The below token structure will be generated</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[\n    { type: &#39;paren&#39;,  value: &#39;(&#39;        },\n    { type: &#39;name&#39;,   value: &#39;add&#39;      },\n    { type: &#39;number&#39;, value: &#39;2&#39;        },\n    { type: &#39;paren&#39;,  value: &#39;(&#39;        },\n    { type: &#39;name&#39;,   value: &#39;subtract&#39; },\n    { type: &#39;number&#39;, value: &#39;4&#39;        },\n    { type: &#39;number&#39;, value: &#39;2&#39;        },\n    { type: &#39;paren&#39;,  value: &#39;)&#39;        },\n    { type: &#39;paren&#39;,  value: &#39;)&#39;        },\n]</code></pre></div>\n<p>Below is the code of how a tokenizer generates the tokens.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/**\n * ============================================================================\n*                                   (/^▽^)/\n*                                THE TOKENIZER!\n* ============================================================================\n*/</span>\n\n<span class=\"token comment\">/**\n* the tokenizer is going to take the code and covert it to an array of tokens\n*\n* (add 2 (subtract 4 2))   =>   [{ type: 'paren', value: '(' }, { type: 'name', value: 'add'} ...]\n*/</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">tokenizer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token comment\">// Let's keep a variable called current that will be used as a cursor.</span>\n<span class=\"token keyword\">let</span> current <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Token array for inserting the tokens.</span>\n<span class=\"token keyword\">let</span> tokens <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">&lt;</span> input<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// Take the current character</span>\n    <span class=\"token keyword\">let</span> char <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// The first thing we want to check for is an open parenthesis. This will </span>\n    <span class=\"token comment\">// later we will use this for `CallExpression`. As of now we will only take care</span>\n    <span class=\"token comment\">// of the character. if we come across one we push them in the token array with type</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>char <span class=\"token operator\">===</span> <span class=\"token string\">'('</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        tokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'paren'</span><span class=\"token punctuation\">,</span> value<span class=\"token operator\">:</span> <span class=\"token string\">'('</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// Then we increment `current` and continue to the next cycle of the loop</span>\n        current<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Next we're going to check for a closing parenthesis. We do the same exact</span>\n    <span class=\"token comment\">// thing as before.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>char <span class=\"token operator\">===</span> <span class=\"token string\">')'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        tokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'paren'</span><span class=\"token punctuation\">,</span>value<span class=\"token operator\">:</span> <span class=\"token string\">')'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        current<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Let's check for whitespaces. We need them because whitespace exists to </span>\n    <span class=\"token comment\">// separate characters, but it isn't actually important for us to store as a token.</span>\n    <span class=\"token comment\">// We would only throw it out later.</span>\n    <span class=\"token keyword\">let</span> <span class=\"token constant\">WHITESPACE</span> <span class=\"token operator\">=</span> <span class=\"token regex\">/\\s/</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">WHITESPACE</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        current<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Next let us take care of number tokens. It's a bit different because a number can </span>\n    <span class=\"token comment\">// have a continuous sequence and we need to  capture the entire sequence of characters</span>\n    <span class=\"token comment\">// as one token.</span>\n    <span class=\"token comment\">//</span>\n    <span class=\"token comment\">//   (add 123 456)</span>\n    <span class=\"token comment\">//        ^^^ ^^^</span>\n    <span class=\"token comment\">//        Only two separate tokens</span>\n    <span class=\"token comment\">//</span>\n    <span class=\"token comment\">// So we start this off when we encounter the first number in a sequence.</span>\n    <span class=\"token keyword\">let</span> <span class=\"token constant\">NUMBERS</span> <span class=\"token operator\">=</span> <span class=\"token regex\">/[0-9]/</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">NUMBERS</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// We're going to create a `value` string that we are going to push</span>\n        <span class=\"token comment\">// characters to.</span>\n        <span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// Loop through the characters in the sequence until we encounter a character that </span>\n        <span class=\"token comment\">// is not a number. Push each character that is a number to our `value` and </span>\n        <span class=\"token comment\">// incrementing `current` as we go.</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">NUMBERS</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            value <span class=\"token operator\">+=</span> char<span class=\"token punctuation\">;</span>\n            char <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        tokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">,</span> value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// So what about strings then we need to parse the strings as well right. So how do we </span>\n    <span class=\"token comment\">// do it 🤷‍♀️. You guessed it right we need to look for the start and end of a double quote.</span>\n    <span class=\"token comment\">//</span>\n    <span class=\"token comment\">//   (concat \"foo\" \"bar\")</span>\n    <span class=\"token comment\">//            ^^^   ^^^ string tokens</span>\n    <span class=\"token comment\">//</span>\n    <span class=\"token comment\">// The same logic can be applied which we used for numbers numberWe'll start by </span>\n    <span class=\"token comment\">// checking for the opening quote:</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>char <span class=\"token operator\">===</span> <span class=\"token string\">'\"'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// value variable to insert the characters to form the string.</span>\n        <span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n        char <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>char <span class=\"token operator\">!==</span> <span class=\"token string\">'\"'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            value <span class=\"token operator\">+=</span> char<span class=\"token punctuation\">;</span>\n            char <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        char <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        tokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">,</span> value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Lastly let's take care of the `name token`. Names are sequence of letters,</span>\n    <span class=\"token comment\">// that are the names of functions in our lisp syntax.</span>\n    <span class=\"token comment\">//</span>\n    <span class=\"token comment\">//   (add 2 4)</span>\n    <span class=\"token comment\">//    ^^^</span>\n    <span class=\"token comment\">//    Name token</span>\n    <span class=\"token comment\">//</span>\n    <span class=\"token keyword\">let</span> <span class=\"token constant\">LETTERS</span> <span class=\"token operator\">=</span> <span class=\"token regex\">/[a-z]/i</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">LETTERS</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// Again we're just going to loop through all the letters pushing them to</span>\n        <span class=\"token comment\">// a value.</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">LETTERS</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            value <span class=\"token operator\">+=</span> char<span class=\"token punctuation\">;</span>\n            char <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        tokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Finally if we have not matched any characters then let's throw the below error</span>\n    <span class=\"token comment\">// and completely exit.</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">'I\\'m not really sure what this character is : '</span> <span class=\"token operator\">+</span> char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Then at the end of our `tokenizer` we simply return the tokens array.</span>\n<span class=\"token keyword\">return</span> tokens<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// export the tokenizer module final compiler...</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> tokenizer<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">Syntactic Analysis</code> takes the token and reformats them into a tree-like structure called <code class=\"language-text\">Abstract Syntax Tree or AST</code> that describes the token's relationship with one another. This is also called as Intermediate representation or AST.</p>\n<p>Below is what an AST looks like</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    type: &#39;Program&#39;,\n    body: [{\n        type: &#39;CallExpression&#39;,\n        name: &#39;add&#39;,\n        params: [{\n            type: &#39;NumberLiteral&#39;,\n            value: &#39;2&#39;,\n            }, {\n            type: &#39;CallExpression&#39;,\n            name: &#39;subtract&#39;,\n            params: [{\n                type: &#39;NumberLiteral&#39;,\n                value: &#39;4&#39;,\n            }, {\n                type: &#39;NumberLiteral&#39;,\n                value: &#39;2&#39;,\n            }]\n        }]\n    }]\n}</code></pre></div>\n<p>The code below is how the parser generates the <code class=\"language-text\">AST</code> by taking the output from the tokenizer as input.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/**\n * ============================================================================\n*                                 ヽ/❀o ل͜ o\\ﾉ\n*                                THE PARSER!!!\n* ============================================================================\n*/</span>\n\n<span class=\"token comment\">/**\n* For our parser take the token array from the output of tokenizer and tranform it to AST\n*\n*   [{ type: 'paren', value: '(' }, { type:'name', value: 'add'} ...]   =>   { type: 'Program', body: [...] }\n*/</span>\n\n<span class=\"token comment\">// Let's start by defining a function called parser that accepts an array of token</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">parser</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">tokens</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// Let's keep a variable called current that will be used as a cursor.</span>\n    <span class=\"token keyword\">let</span> current <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// But this time we're going to use recursion instead of a `while` loop. So we</span>\n    <span class=\"token comment\">// define a `walk` function.</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">walk</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\">// Inside this function let's start by taking the value of the current token</span>\n        <span class=\"token keyword\">let</span> token <span class=\"token operator\">=</span> tokens<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// Let's spilt the each type of token into different nodes</span>\n        <span class=\"token comment\">// starting off with `number` tokens.</span>\n        <span class=\"token comment\">//</span>\n        <span class=\"token comment\">// We test to see if we have a `number` token.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// If we have one, we'll increment `current`.</span>\n            current<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// Return a new AST node called `NumberLiteral` and set value to the </span>\n            <span class=\"token comment\">// value of our token.</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'NumberLiteral'</span><span class=\"token punctuation\">,</span> value<span class=\"token operator\">:</span> token<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// Again let's do the same for a `StringLiteral` node.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            current<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'StringLiteral'</span><span class=\"token punctuation\">,</span> value<span class=\"token operator\">:</span> token<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// Next we're going to look for CallExpressions. We start this off when we</span>\n        <span class=\"token comment\">// encounter an open parenthesis.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> token<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'paren'</span> <span class=\"token operator\">&amp;&amp;</span> token<span class=\"token punctuation\">.</span>value <span class=\"token operator\">===</span> <span class=\"token string\">'('</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token comment\">// We'll increment `current` to skip the parenthesis since we don't care</span>\n            <span class=\"token comment\">// about it in our AST.</span>\n            token <span class=\"token operator\">=</span> tokens<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// we will create a node with the type `CallExpression`, and we're going</span>\n            <span class=\"token comment\">// to set the name as the current token's value since the next token after</span>\n            <span class=\"token comment\">// the open parenthesis is the name of the function.</span>\n            <span class=\"token keyword\">let</span> node <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n                type<span class=\"token operator\">:</span> <span class=\"token string\">'CallExpression'</span><span class=\"token punctuation\">,</span>\n                name<span class=\"token operator\">:</span> token<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span>\n                params<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// We increment `current` *again* to skip the name token.</span>\n            token <span class=\"token operator\">=</span> tokens<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// Next we would like to add each token as `params` for the `CallExpression` till we</span>\n            <span class=\"token comment\">// encounter a closing params.</span>\n            <span class=\"token comment\">//</span>\n            <span class=\"token comment\">// For this let's make use of Recursion instead of infinitely looping on each result.</span>\n            <span class=\"token comment\">//</span>\n            <span class=\"token comment\">// To explain this let's look at the LISP snippet below which includes multiple paranthesis.</span>\n            <span class=\"token comment\">//</span>\n            <span class=\"token comment\">//   (add 2 (subtract 4 2))</span>\n            <span class=\"token comment\">//</span>\n            <span class=\"token comment\">// The token array will have multiple nested paranthesis as well</span>\n            <span class=\"token comment\">//</span>\n            <span class=\"token comment\">//   [</span>\n            <span class=\"token comment\">//     { type: 'paren',  value: '('        },</span>\n            <span class=\"token comment\">//     { type: 'name',   value: 'add'      },</span>\n            <span class=\"token comment\">//     { type: 'number', value: '2'        },</span>\n            <span class=\"token comment\">//     { type: 'paren',  value: '('        },</span>\n            <span class=\"token comment\">//     { type: 'name',   value: 'subtract' },</span>\n            <span class=\"token comment\">//     { type: 'number', value: '4'        },</span>\n            <span class=\"token comment\">//     { type: 'number', value: '2'        },</span>\n            <span class=\"token comment\">//     { type: 'paren',  value: ')'        }, &lt;&lt;&lt; Closing parenthesis</span>\n            <span class=\"token comment\">//     { type: 'paren',  value: ')'        }, &lt;&lt;&lt; Closing parenthesis</span>\n            <span class=\"token comment\">//   ]</span>\n            <span class=\"token comment\">//</span>\n            <span class=\"token comment\">// We're going to rely on the nested `walk` function to increment our</span>\n            <span class=\"token comment\">// `current` variable past any nested `CallExpression`.</span>\n\n            <span class=\"token comment\">// So we create a `while` loop that will continue until it encounters a</span>\n            <span class=\"token comment\">// token with a `type` of `'paren'` and a `value` of a closing</span>\n            <span class=\"token comment\">// parenthesis.</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>\n                <span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">.</span>type <span class=\"token operator\">!==</span> <span class=\"token string\">'paren'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n                <span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'paren'</span> <span class=\"token operator\">&amp;&amp;</span> token<span class=\"token punctuation\">.</span>value <span class=\"token operator\">!==</span> <span class=\"token string\">')'</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// we'll call the `walk` function which will return a `node` and we'll</span>\n                <span class=\"token comment\">// push it into our `node.params`.</span>\n                node<span class=\"token punctuation\">.</span>params<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">walk</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                token <span class=\"token operator\">=</span> tokens<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\">// Finally we will increment `current` one last time to skip the closing</span>\n            <span class=\"token comment\">// parenthesis.</span>\n            current<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// And return the node.</span>\n            <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// Again, if we haven't recognized the token type by now we're going to</span>\n        <span class=\"token comment\">// throw an error.</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Now, we're going to create our AST which will have a root which is a</span>\n    <span class=\"token comment\">// `Program` node.</span>\n    <span class=\"token keyword\">let</span> ast <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        type<span class=\"token operator\">:</span> <span class=\"token string\">'Program'</span><span class=\"token punctuation\">,</span>\n        body<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// And we're going to kickstart our `walk` function, pushing nodes to our</span>\n    <span class=\"token comment\">// `ast.body` array.</span>\n    <span class=\"token comment\">//</span>\n    <span class=\"token comment\">// The reason we are doing this inside a loop is because our program can have</span>\n    <span class=\"token comment\">// `CallExpression` after one another instead of being nested.</span>\n    <span class=\"token comment\">//</span>\n    <span class=\"token comment\">//   (add 2 2)</span>\n    <span class=\"token comment\">//   (subtract 4 2)</span>\n    <span class=\"token comment\">//</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">&lt;</span> tokens<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ast<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">walk</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// At the end of our parser we'll return the AST.</span>\n    <span class=\"token keyword\">return</span> ast<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Just exporting our parser to be used in the final compiler...</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> parser<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<h3>Transformation</h3>\n<p>The next stage of the compiler is the transforamtion stage. In this stage we take the <code class=\"language-text\">AST</code> from the previous step and do manipulation over it or create a new <code class=\"language-text\">AST</code> from the existing <code class=\"language-text\">AST</code>. It can manipulate the <code class=\"language-text\">AST</code> in the same language or it can translate it to an entirelly different language.</p>\n<p>Now let's start transforming our <code class=\"language-text\">AST</code>.</p>\n<p>If we look at the <code class=\"language-text\">AST</code> closely we have node with a certain property each of these nodes are know as AST node. These nodes define an isolated part of the tree.</p>\n<p>For instance for \"NumberLiteral\" we have a node.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    type: &#39;NumberLiteral&#39;,\n    value: &#39;2&#39;,\n}</code></pre></div>\n<p>and if we conider a \"CallExpression\" then we have the node as</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    type: &#39;CallExpression&#39;,\n    name: &#39;subtract&#39;,\n    params: [\n        // nested nodes \n    ],\n}</code></pre></div>\n<p>When we are taversing the <code class=\"language-text\">AST</code> we either add, remove or manipulate the nodes or we can create a new AST from the existing AST.</p>\n<p>Since we are targetting a new language let's create a new AST while keeping the old one as reference.</p>\n<ul>\n<li><code class=\"language-text\">Traversal</code>: This process involves visiting all the nodes in the AST with depth-first approach. Comsider the <code class=\"language-text\">AST</code></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    type: &#39;Program&#39;,\n    body: [{\n        type: &#39;CallExpression&#39;,\n        name: &#39;add&#39;,\n        params: [{\n        type: &#39;NumberLiteral&#39;,\n        value: &#39;2&#39;\n        }, {\n        type: &#39;CallExpression&#39;,\n        name: &#39;subtract&#39;,\n        params: [{\n            type: &#39;NumberLiteral&#39;,\n            value: &#39;4&#39;\n        }, {\n            type: &#39;NumberLiteral&#39;,\n            value: &#39;2&#39;\n        }]\n        }]\n    }]\n}</code></pre></div>\n<p>So for the <code class=\"language-text\">AST</code> above we would go like:</p>\n<ol>\n<li>Program - starting at the top level of the AST</li>\n<li>CallExpression (add) - Next let us move to the first node of the program body</li>\n<li>NumberLiteral (2) - Going to to the first element of CallExpression's params</li>\n<li>CallExpression (subtract) - Going to the second element of CallExpression's params</li>\n<li>NumberLiteral (4) - Going to the first element of CallExpression's params</li>\n<li>NumberLiteral (2) - Going to the second element of CallExpression's params</li>\n</ol>\n<p>If we are going to manipulate the nodes directly we would likely to introduce lot of scenarios, so we better we visit each nodes.</p>\n<ul>\n<li><code class=\"language-text\">Vistors</code>: So visitor is going to be an object that will have methods to handle different node types.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> visitor <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NumberLiteral</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">CallExpression</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Whenever we find a match with AST node and visitor object type we will call the methods in the visitor object.</p>\n<p>Inorder to make things simple and to keep track of the modified node let's pass the node and reference to the parent node.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> visitor <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NumberLiteral</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> parent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">CallExpression</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> parent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Okk so there is a teeny weeny problem with that structure 😑. Imagine we go down the tree of a node as soon as we finish up at the bottom of that node we may endup calling an exit function which may lead to ignoring of other nodes.</p>\n<p>In order to support this the final form of our visitor should look like.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> visitor <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    NumberLiteral<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">enter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> parent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> parent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> </code></pre></div>\n<p>Looks good now. Now lets write the snippet for our traverser.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/**\n * ============================================================================\n*                                 ⌒(❀>◞౪◟&lt;❀)⌒\n*                               THE TRAVERSER!!!\n* ============================================================================\n*/</span>\n\n<span class=\"token comment\">/**\n* So our traverser function will accept an AST and also a visior node this visitor\n* node method will be used for performing a mapping with the AST nodes.\n*\n*   traverse(ast, {\n*     Program: (node, parent) => {\n*       //do something here\n*     },\n*\n*     CallExpression: (node, parent) => {\n*       //do something here\n*     },\n*\n*     NumberLiteral: (node, parent) => {\n*      //do something here\n*     },\n*   });\n*/</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">traverser</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ast<span class=\"token punctuation\">,</span> visitor</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// Iterates over the array and call the next function traverseNode with reference </span>\n    <span class=\"token comment\">// to the parent.</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">traverseArray</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">array<span class=\"token punctuation\">,</span> parent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        array<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">child</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">traverseNode</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// accepts a node and parent so that it can pass both to our visitor methods</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">traverseNode</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> parent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\">// We start by testing for the existence of a method on the visitor with a</span>\n        <span class=\"token comment\">// matching `type`.</span>\n        <span class=\"token keyword\">let</span> methods <span class=\"token operator\">=</span> visitor<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// If there is an `enter` method for this node type we'll call it with the</span>\n        <span class=\"token comment\">// `node` and its `parent`.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>methods <span class=\"token operator\">&amp;&amp;</span> methods<span class=\"token punctuation\">.</span>enter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            methods<span class=\"token punctuation\">.</span><span class=\"token function\">enter</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// Next we are going to split things up by the current node type.</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token comment\">// Let's start with the 'Program' array and then call the traverseArray </span>\n            <span class=\"token comment\">// method for the body node</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'Program'</span><span class=\"token operator\">:</span>\n                <span class=\"token function\">traverseArray</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// Next we take care of 'CallExpression' since 'CallExpressions' have params</span>\n            <span class=\"token comment\">// we will pass that as the array params.</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'CallExpression'</span><span class=\"token operator\">:</span>\n                <span class=\"token function\">traverseArray</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>params<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// `NumberLiteral` and `StringLiteral` We don't have anything to do so we just break</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'NumberLiteral'</span><span class=\"token operator\">:</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'StringLiteral'</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// If node type is not recognized we simply throw an error</span>\n            <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// if `exit` method is encountered for this node type we'll call it with the</span>\n        <span class=\"token comment\">// `node` and its `parent`.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>methods <span class=\"token operator\">&amp;&amp;</span> methods<span class=\"token punctuation\">.</span>exit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            methods<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Let's call the traverserNode function with the parent parameter as null </span>\n    <span class=\"token comment\">// because the top level does not have a parent</span>\n    <span class=\"token function\">traverseNode</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// exporting the traverser method</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> traverser<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Next up let's write the transformer function.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">    <span class=\"token keyword\">var</span> traverser <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./traverser'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n    * ============================================================================\n    *                                   ⁽(◍˃̵͈̑ᴗ˂̵͈̑)⁽\n    *                              THE TRANSFORMER!!!\n    * ============================================================================\n    */</span>\n\n    <span class=\"token comment\">/**\n    * Our transformer is going to take the ast and pass it to the traverser and for\n    * the new AST.\n    *\n    * ----------------------------------------------------------------------------\n    *   Original AST                     |   Transformed AST\n    * ----------------------------------------------------------------------------\n    *   {                                |   {\n    *     type: 'Program',               |     type: 'Program',\n    *     body: [{                       |     body: [{\n    *       type: 'CallExpression',      |       type: 'ExpressionStatement',\n    *       name: 'add',                 |       expression: {\n    *       params: [{                   |         type: 'CallExpression',\n    *         type: 'NumberLiteral',     |         callee: {\n    *         value: '2'                 |           type: 'Identifier',\n    *       }, {                         |           name: 'add'\n    *         type: 'CallExpression',    |         },\n    *         name: 'subtract',          |         arguments: [{\n    *         params: [{                 |           type: 'NumberLiteral',\n    *           type: 'NumberLiteral',   |           value: '2'\n    *           value: '4'               |         }, {\n    *         }, {                       |           type: 'CallExpression',\n    *           type: 'NumberLiteral',   |           callee: {\n    *           value: '2'               |             type: 'Identifier',\n    *         }]                         |             name: 'subtract'\n    *       }]                           |           },\n    *     }]                             |           arguments: [{\n    *   }                                |             type: 'NumberLiteral',\n    *                                    |             value: '4'\n    * ---------------------------------- |           }, {\n    *                                    |             type: 'NumberLiteral',\n    *                                    |             value: '2'\n    *                                    |           }]\n    * (sorry the other one is longer 😜) |         }\n    *                                    |       }\n    *                                    |     }]\n    *                                    |   }\n    * ----------------------------------------------------------------------------\n    */</span>\n\n    <span class=\"token comment\">// Transformer function with the ast as params</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">transformer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ast</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\">// A new AST with initalization</span>\n        <span class=\"token keyword\">let</span> newAst <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n            type<span class=\"token operator\">:</span> <span class=\"token string\">'Program'</span><span class=\"token punctuation\">,</span>\n            body<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// We are going to pass a property called context to the node which keeps the reference</span>\n        <span class=\"token comment\">// to the parent</span>\n        ast<span class=\"token punctuation\">.</span>_context <span class=\"token operator\">=</span> newAst<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// Let's call the traverser function with ast and our visitor</span>\n        <span class=\"token function\">traverser</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// Take care of NumberLiteral</span>\n            NumberLiteral<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// We'll visit them on enter.</span>\n                <span class=\"token function\">enter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> parent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\">// create a node call 'NumberLiteral' that will push the parent context.</span>\n                        parent<span class=\"token punctuation\">.</span>_context<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n                            type<span class=\"token operator\">:</span> <span class=\"token string\">'NumberLiteral'</span><span class=\"token punctuation\">,</span>\n                            value<span class=\"token operator\">:</span> node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span>\n                        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n            <span class=\"token comment\">// Let's do the same for `StringLiteral`</span>\n            StringLiteral<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">enter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> parent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    parent<span class=\"token punctuation\">.</span>_context<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n                        type<span class=\"token operator\">:</span> <span class=\"token string\">'StringLiteral'</span><span class=\"token punctuation\">,</span>\n                        value<span class=\"token operator\">:</span> node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n            <span class=\"token comment\">// So `CallExpression` should be taken care like this.</span>\n            CallExpression<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">enter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> parent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                    <span class=\"token comment\">//  create a `CallExpression` node with a nested `Identifier`.</span>\n                    <span class=\"token keyword\">let</span> expression <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n                        type<span class=\"token operator\">:</span> <span class=\"token string\">'CallExpression'</span><span class=\"token punctuation\">,</span>\n                        callee<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                            type<span class=\"token operator\">:</span> <span class=\"token string\">'Identifier'</span><span class=\"token punctuation\">,</span>\n                            name<span class=\"token operator\">:</span> node<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>\n                        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                        arguments<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n                    <span class=\"token comment\">// Let's create a new context for the original 'CallExpression' so that we can push</span>\n                    <span class=\"token comment\">// arguments </span>\n                    node<span class=\"token punctuation\">.</span>_context <span class=\"token operator\">=</span> expression<span class=\"token punctuation\">.</span>arguments<span class=\"token punctuation\">;</span>\n\n                    <span class=\"token comment\">// Ceck the parent node is a `CallExpression` if it is not then</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">.</span>type <span class=\"token operator\">!==</span> <span class=\"token string\">'CallExpression'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                        <span class=\"token comment\">// wrap our `CallExpression` node with an `ExpressionStatement`. </span>\n                        <span class=\"token comment\">// This is done because the top level `CallExpression` in JavaScript are actually </span>\n                        <span class=\"token comment\">// statements.</span>\n                        expression <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n                            type<span class=\"token operator\">:</span> <span class=\"token string\">'ExpressionStatement'</span><span class=\"token punctuation\">,</span>\n                            expression<span class=\"token operator\">:</span> expression<span class=\"token punctuation\">,</span>\n                        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n\n                    <span class=\"token comment\">// Lat but not the least wrap the expression with the parent context</span>\n                    parent<span class=\"token punctuation\">.</span>_context<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>expression<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// return the new AST</span>\n        <span class=\"token keyword\">return</span> newAst<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// export transformer </span>\n    module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> transformer<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<h3>Code Generation</h3>\n<p>This is the final step in our compiler design this phase is going to generate the code for the new program by taking the AST. At times compilers do things that will overlap with the transformation.</p>\n<p>Code generators work in different ways, some will reuse the tokens from the earlier and others will generate the code in a linear fashion by generating a new AST.</p>\n<p>In our code generator we are going to use the same AST and generate our code.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">    <span class=\"token comment\">/**\n    * ============================================================================\n    *                               ヾ（〃＾∇＾）ﾉ♪\n    *                            THE CODE GENERATOR!!!!\n    * ============================================================================\n    */</span>\n\n    <span class=\"token comment\">/**\n    * Our CodeGenerator is going to call itself recursively to to print a string \n    * The code generator is quite straight forward to understand\n    */</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">codeGenerator</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\">// We'll break things down by the `type` of the `node`.</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'Program'</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>codeGenerator<span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// For `ExpressionStatement` call the codegenerator function and add a semicolon</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'ExpressionStatement'</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n                    <span class=\"token function\">codeGenerator</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>expression<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">';'</span>\n                <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// For `CallExpression` we will print the `callee`, and call the codeGenerator</span>\n            <span class=\"token comment\">// recursively so that the end result of recursion is going to be a string </span>\n            <span class=\"token comment\">// the arguments are concatenated as shown below</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'CallExpression'</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n                    <span class=\"token function\">codeGenerator</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>callee<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">'('</span> <span class=\"token operator\">+</span>\n                    node<span class=\"token punctuation\">.</span>arguments<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>codeGenerator<span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">', '</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">')'</span>\n                <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// For identifier we will return the name</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'Identifier'</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// For `NumberLiteral` let's return the value</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'NumberLiteral'</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// For `StringLiteral` we just add quotes arround the value</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">'StringLiteral'</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token string\">'\"'</span> <span class=\"token operator\">+</span> node<span class=\"token punctuation\">.</span>value <span class=\"token operator\">+</span> <span class=\"token string\">'\"'</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// And if we haven't recognized the node, we'll throw an error.</span>\n            <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// export code generator</span>\n    module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> codeGenerator<span class=\"token punctuation\">;</span></code></pre></div>\n<p>That's it we are done with our compiler 👏👏👏.</p>\n<p>For the last part let us call the compiler program in a file.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> tokenizer     <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./tokenizer'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> parser        <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./parser'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> transformer   <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./transformer'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> codeGenerator <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./code-generator'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n* ============================================================================\n*                                  (۶* ‘ヮ’)۶”\n*                         !!!!!!!!THE COMPILER!!!!!!!!\n* ============================================================================\n*/</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">compiler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> tokens <span class=\"token operator\">=</span> <span class=\"token function\">tokenizer</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> ast    <span class=\"token operator\">=</span> <span class=\"token function\">parser</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> newAst <span class=\"token operator\">=</span> <span class=\"token function\">transformer</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> output <span class=\"token operator\">=</span> <span class=\"token function\">codeGenerator</span><span class=\"token punctuation\">(</span>newAst<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// and simply return the output!</span>\n    <span class=\"token keyword\">return</span> output<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> compiler<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ol>"}